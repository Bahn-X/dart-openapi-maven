part of {{pubName}}.api;

{{#operations}}

class {{classname}} {
  final ApiClient apiClient;

  {{classname}}(this.apiClient) : assert(apiClient != null);

  {{#operation}}
  /// {{summary}}
  ///
  /// {{notes}}
  {{#returnType}}Future<{{{returnType}}}> {{/returnType}}{{^returnType}}Future {{/returnType}}{{nickname}}({{#allParams}}{{#required}}{{{dataType}}} {{paramName}}{{#hasMore}}, {{/hasMore}}{{/required}}{{/allParams}}{{#hasOptionalParams}}{Options options{{#hasParams}}, {{/hasParams}}{{#allParams}}{{^required}}{{{dataType}}} {{paramName}}{{#hasMore}}, {{/hasMore}}{{/required}}{{/allParams}} }{{/hasOptionalParams}}{{^hasOptionalParams}}{{#hasParams}}, {{/hasParams}}{Options options}{{/hasOptionalParams}}) async {
    Object postBody{{#bodyParam}} = {{paramName}}{{/bodyParam}};

    // verify required params are set
    {{#allParams}}
      {{#required}}
    if({{paramName}} == null) {
     throw ApiException(400, "Missing required param: {{paramName}}");
    }
      {{/required}}
    {{/allParams}}

    // create path and map variables
    String path = "{{{path}}}"{{#pathParams}}.replaceAll("{" + "{{baseName}}" + "}", {{{paramName}}}.toString()){{/pathParams}};

    // query params
    List<QueryParam> queryParams = [];
    Map<String, String> headerParams = {};
    {{#hasProduces}}headerParams['Accept'] = "{{#produces}}{{mediaType}}{{#hasMore}},{{/hasMore}}{{/produces}}";{{/hasProduces}}

    {{#queryParams}}
    {{^required}}
    if({{paramName}} != null) {
    {{/required}}
      queryParams.addAll(convertParametersForCollectionFormat(apiClient.deserializeDelegate, "{{collectionFormat}}", "{{baseName}}", {{paramName}}));
    {{^required}}
    }
    {{/required}}
    {{/queryParams}}
    {{#headerParams}}
    headerParams["{{baseName}}"] = {{paramName}};
    {{/headerParams}}

    List<String> contentTypes = [{{#consumes}}"{{{mediaType}}}"{{#hasMore}},{{/hasMore}}{{/consumes}}];

    String contentType = contentTypes.isNotEmpty ? contentTypes[0] : null;
    List<String> authNames = [{{#authMethods}}"{{name}}"{{#hasMore}}, {{/hasMore}}{{/authMethods}}];

    if(contentType != null && contentType.startsWith("multipart/form-data")) {
      Map<String, dynamic> formData = {};

      {{#formParams}}
      {{^isFile}}
      if ({{paramName}} != null) {
        formData['{{baseName}}'] = parameterToString({{paramName}});
      }
      {{/isFile}}
      {{#isFile}}
      if ({{paramName}} != null) {
        formData['{{baseName}}'] = {{paramName}};
      }
      {{/isFile}}
      {{/formParams}}
      if (formData.length > 0) {
        postBody = FormData.fromMap(formData);
      }
    }{{^bodyParam}} else {
      {{#hasFormParams}}
          Map<String, dynamic> formParams = {};
        {{#formParams}}
          {{^isFile}}
              if ({{paramName}} != null)
              formParams['{{baseName}}'] = parameterToString({{paramName}});
          {{/isFile}}
        {{/formParams}}
          postBody = formParams;
      {{/hasFormParams}}
  {{^hasFormParams}}postBody = null;{{/hasFormParams}}
    }
    {{/bodyParam}}

    Options opt = options ?? Options();
    opt.headers = headerParams;
    opt.method = '{{httpMethod}}';

    var response = await apiClient.invokeAPI(path,
                                             queryParams,
                                             postBody,
                                             headerParams,
                                             authNames, opt);

    if(response.statusCode >= 400) {
      throw ApiException(response.statusCode, await decodeBodyBytes(response));
    } else if(response.body != null) {
      {{#isListContainer}}
        {{#returnType}}
      return (apiClient.deserialize(await decodeBodyBytes(response), '{{{returnType}}}') as List).map((item) => item as {{returnBaseType}}).toList();
        {{/returnType}}
      {{/isListContainer}}
      {{^isListContainer}}
        {{#isMapContainer}}
          {{#returnType}}
      return {{{returnType}}}.from(apiClient.deserialize(await decodeBodyBytes(response), '{{{returnType}}}'));
          {{/returnType}};
        {{/isMapContainer}}
        {{^isMapContainer}}
          {{#returnType}}
      return apiClient.deserialize(await decodeBodyBytes(response), '{{{returnType}}}') as {{{returnType}}};
          {{/returnType}}
        {{/isMapContainer}}
      {{/isListContainer}}
    } else {
      return{{#returnType}} null{{/returnType}};
    }
  }
  {{/operation}}
}
{{/operations}}
